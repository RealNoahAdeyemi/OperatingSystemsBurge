#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>

#define MAX_TOKENS 100
#define MAX_LINE 1024

extern char **environ;

volatile pid_t fg_child_pid = 0; // For signal/timeout handling

//Code is generated by You.com AI

void sigint_handler(int signo) {
    write(STDOUT_FILENO, "\n", 1);
}

void sigalrm_handler(int signo) {
    if (fg_child_pid > 0) {
        kill(fg_child_pid, SIGKILL);
        write(STDOUT_FILENO, "\n[Process killed after 10 seconds]\n", 35);
    }
}

// Expand $VAR to its value
char *expand_var(const char *token) {
    if (token[0] == '$') {
        char *val = getenv(token + 1);
        return val ? strdup(val) : strdup("");
    }
    return strdup(token);
}

// Tokenize input, expanding $VAR
int tokenize(char *line, char **tokens) {
    int count = 0;
    char *tok = strtok(line, " \t\n");
    while (tok && count < MAX_TOKENS - 1) {
        if (tok[0] == '$') {
            tokens[count++] = expand_var(tok);
        } else {
            tokens[count++] = strdup(tok);
        }
        tok = strtok(NULL, " \t\n");
    }
    tokens[count] = NULL;
    return count;
}

void print_prompt() {
    char cwd[PATH_MAX];
    if (getcwd(cwd, sizeof(cwd))) {
        printf("%s> ", cwd);
        fflush(stdout);
    } else {
        perror("getcwd");
        printf("> ");
        fflush(stdout);
    }
}

void builtin_echo(char **args) {
    int i;
    for (i = 1; args[i]; i++) {
        printf("%s", args[i]);
        if (args[i + 1]) printf(" ");
    }
    printf("\n");
}

void builtin_env(char **args) {
    int i;
    if (args[1]) {
        for (i = 1; args[i]; i++) {
            char *val = getenv(args[i]);
            if (val) printf("%s\n", val);
        }
    } else {
        char **env;
        for (env = environ; *env; env++) {
            printf("%s\n", *env);
        }
    }
}

void builtin_setenv(char **args) {
    if (args[1] && args[2]) {
        if (setenv(args[1], args[2], 1) != 0) {
            perror("setenv");
        }
    } else {
        fprintf(stderr, "Usage: setenv VAR VALUE\n");
    }
}

// Helper: find token index
int find_token(char **tokens, const char *token) {
    int i;
    for (i = 0; tokens[i]; i++) {
        if (strcmp(tokens[i], token) == 0) return i;
    }
    return -1;
}

// Execute a command with possible I/O redirection
void exec_with_redirection(char **tokens) {
    int out_idx = find_token(tokens, ">");
    int in_idx = find_token(tokens, "<");

    // Output redirection
    if (out_idx != -1 && tokens[out_idx + 1]) {
        int fd = open(tokens[out_idx + 1], O_WRONLY | O_CREAT | O_TRUNC, 0644);
        if (fd < 0) { perror("open"); exit(1); }
        dup2(fd, STDOUT_FILENO);
        close(fd);
        tokens[out_idx] = NULL;
    }
    // Input redirection
    if (in_idx != -1 && tokens[in_idx + 1]) {
        int fd = open(tokens[in_idx + 1], O_RDONLY);
        if (fd < 0) { perror("open"); exit(1); }
        dup2(fd, STDIN_FILENO);
        close(fd);
        tokens[in_idx] = NULL;
    }
    execvp(tokens[0], tokens);
    perror("execvp");
    exit(1);
}

// Execute a pipeline: left | right
void exec_pipeline(char **left, char **right) {
    int fd[2];
    pid_t pid1, pid2;

    pipe(fd);

    pid1 = fork();
    if (pid1 == 0) {
        // Left child: stdout -> pipe
        signal(SIGINT, SIG_DFL);
        close(fd[0]);
        dup2(fd[1], STDOUT_FILENO);
        close(fd[1]);
        exec_with_redirection(left);
        exit(1);
    }

    pid2 = fork();
    if (pid2 == 0) {
        // Right child: stdin <- pipe
        signal(SIGINT, SIG_DFL);
        close(fd[1]);
        dup2(fd[0], STDIN_FILENO);
        close(fd[0]);
        exec_with_redirection(right);
        exit(1);
    }

    close(fd[0]);
    close(fd[1]);
    waitpid(pid1, NULL, 0);
    waitpid(pid2, NULL, 0);
}

int main() {
    char line[MAX_LINE];
    char *tokens[MAX_TOKENS];
    int ntokens, background, pipe_idx, i;
    pid_t pid;
    signal(SIGINT, sigint_handler);
    signal(SIGALRM, sigalrm_handler);

    while (1) {
        print_prompt();

        if (!fgets(line, sizeof(line), stdin)) {
            printf("\n");
            break;
        }

        ntokens = tokenize(line, tokens);
        if (ntokens == 0) continue;

        // Background process check
        background = 0;
        if (ntokens > 0 && strcmp(tokens[ntokens - 1], "&") == 0) {
            background = 1;
            free(tokens[ntokens - 1]);
            tokens[ntokens - 1] = NULL;
            ntokens--;
        }

        // Built-in commands
        if (strcmp(tokens[0], "exit") == 0) {
            for (i = 0; i < ntokens; i++) free(tokens[i]);
            break;
        } else if (strcmp(tokens[0], "cd") == 0) {
            const char *dir = tokens[1] ? tokens[1] : getenv("HOME");
            if (chdir(dir) != 0) {
                perror("cd");
            }
        } else if (strcmp(tokens[0], "pwd") == 0) {
            char cwd[PATH_MAX];
            if (getcwd(cwd, sizeof(cwd))) {
                printf("%s\n", cwd);
            } else {
                perror("pwd");
            }
        } else if (strcmp(tokens[0], "echo") == 0) {
            builtin_echo(tokens);
        } else if (strcmp(tokens[0], "env") == 0) {
            builtin_env(tokens);
        } else if (strcmp(tokens[0], "setenv") == 0) {
            builtin_setenv(tokens);
        } else {
            // Check for pipe
            pipe_idx = find_token(tokens, "|");
            if (pipe_idx != -1) {
                tokens[pipe_idx] = NULL;
                char **left = tokens;
                char **right = &tokens[pipe_idx + 1];
                pid = fork();
                if (pid == 0) {
                    signal(SIGINT, SIG_DFL);
                    exec_pipeline(left, right);
                    exit(0);
                } else {
                    if (!background) {
                        fg_child_pid = pid;
                        alarm(10);
                        waitpid(pid, NULL, 0);
                        alarm(0);
                        fg_child_pid = 0;
                    } else {
                        printf("[Background pid %d]\n", pid);
                    }
                }
            } else {
                // No pipe: regular command, possibly with redirection
                pid = fork();
                if (pid < 0) {
                    perror("fork");
                } else if (pid == 0) {
                    signal(SIGINT, SIG_DFL);
                    exec_with_redirection(tokens);
                    exit(1);
                } else {
                    if (!background) {
                        fg_child_pid = pid;
                        alarm(10);
                        waitpid(pid, NULL, 0);
                        alarm(0);
                        fg_child_pid = 0;
                    } else {
                        printf("[Background pid %d]\n", pid);
                    }
                }
            }
        }

        // Free tokens
        for (i = 0; i < ntokens; i++) {
            free(tokens[i]);
        }
    }
    return 0;
}
